{"version":3,"file":"tzm-section-frontend.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE,gCAAgC,qBAAM;AACxC,UAAU,qBAAM;AAChB,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD,cAAc,SAAS,eAAe,SAAS;AACnG;AACA;;AAEA;AACA,EAAE;;;AAGF;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;AACJ;;AAEA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,iCAAiC;AACjC,qCAAqC,iBAAiB;;AAEtD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK,GAAG;;AAER,oFAAoF;;AAEpF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN,sDAAsD;;AAEtD;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,uBAAuB;;AAEvB;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;;;AAGN;AACA;AACA;AACA;AACA,KAAK,GAAG;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,mEAAmE,gBAAgB;AACnF,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA,OAAO,iCAAiC;AACxC,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E,SAAS;AACT;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;;;AAGN,gDAAgD;;AAEhD;AACA,yDAAyD;;AAEzD;AACA,yBAAyB;;AAEzB;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA,iEAAiE;;AAEjE;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;;;AAGR;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;;;AAGN,8CAA8C;;AAE9C;AACA;AACA,MAAM;AACN;AACA,MAAM;;;AAGN;AACA,iBAAiB,QAAQ;AACzB,oBAAoB,SAAS;AAC7B,iDAAiD,UAAU;AAC3D,gBAAgB,WAAW;AAC3B,KAAK,GAAG;;AAER;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;;AAEA;AACA;AACA;;AAEA,4JAA4J;;AAE5J;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;;AAE1E;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;;;AAGN;AACA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,kCAAkC,MAAM;AACxC,MAAM;;;AAGN;AACA,wEAAwE;;AAExE;AACA;AACA;;AAEA,0CAA0C,UAAU;AACpD;;AAEA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE,gBAAgB,qBAAM;AACxB,QAAQ,qBAAM;AACd,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kCAAkC;AACnE;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA,qDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,aAAa,GAAG,qBAAqB;AAC/F;AACA,UAAU;AACV;AACA;AACA,mDAAmD,aAAa,GAAG,qBAAqB;AACxF;AACA;;AAEA,kDAAkD,aAAa,GAAG,qBAAqB;AACvF;;AAEA;AACA,0CAA0C;;AAE1C,mEAAmE,SAAS;;AAE5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;;;AAGd;AACA;AACA;;AAEA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,cAAc;;;AAGd;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,IAAI,GAAG,4CAA4C;AACzF,WAAW,GAAG;AACd;;AAEA;AACA;AACA,4EAA4E,aAAa,GAAG,oBAAoB;AAChH;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iGAAiG;;AAEjG;AACA;AACA,UAAU;;;AAGV;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS,GAAG;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA,YAAY;;;AAGZ;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA,YAAY;;;AAGZ;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sEAAsE,IAAI;AAC1E,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA,MAAM;;;AAGN;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,MAAM;;;AAGN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B;;AAE7B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;;;AAGV,kDAAkD;;AAElD,iDAAiD;;AAEjD;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,EAAE;AACpB,uBAAuB,GAAG;AAC1B,mBAAmB,EAAE;AACrB,sBAAsB,GAAG;AACzB,OAAO;AACP;;AAEA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;;AAER;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;;AAGd;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,aAAa;AACb,WAAW;AACX,UAAU;;AAEV,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC;;AAElC;AACA,SAAS;AACT,4BAA4B;;AAE5B;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,GAAG,KAAK,GAAG;AACnD,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACpD;;;;;;;UCr8DA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNa;;AAEb;AACAC,uDAAa,IAAI;;AAEjB,SAASC,mBAAT,GAA+B;EAC9BF,kDAAQ,CAACG,QAAQ,CAACC,gBAAT,CAA0B,qBAA1B,CAAD,EAAmD;IAC1DC,KAAK,EAAE;EADmD,CAAnD,CAAR;EAGAL,kDAAQ,CAACG,QAAQ,CAACC,gBAAT,CAA0B,oBAA1B,CAAD,EAAkD;IACzDC,KAAK,EAAE;EADkD,CAAlD,CAAR;EAGAL,kDAAQ,CAACG,QAAQ,CAACC,gBAAT,CAA0B,sBAA1B,CAAD,EAAoD;IAC3DC,KAAK,EAAE;EADoD,CAApD,CAAR;EAGAL,kDAAQ,CAACG,QAAQ,CAACC,gBAAT,CAA0B,oBAA1B,CAAD,EAAkD;IACzDC,KAAK,EAAE;EADkD,CAAlD,CAAR;AAGA;;AAED,SAASC,iBAAT,GAA6B;EAC5B,IAAIC,QAAQ,GAAGJ,QAAQ,CAACC,gBAAT,CAA0B,wBAA1B,CAAf;;EAEA,IAAIG,QAAQ,IAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAlC,EAAqC;IACpCD,QAAQ,CAACE,OAAT,CAAkBC,OAAD,IAAa;MAC7B,IAAIC,QAAQ,GAAGD,OAAO,CAACE,OAAR,CAAgBC,cAA/B;MACA,IAAIC,UAAU,GAAGX,QAAQ,CAACY,aAAT,CAAuBJ,QAAvB,CAAjB;;MAEA,IAAIG,UAAJ,EAAgB;QACf,IAAIE,cAAc,GAAGF,UAAU,CAACG,YAAhC;QACAP,OAAO,CAACQ,KAAR,CAAcC,WAAd,CACC,mBADD,EAECH,cAAc,GAAG,IAFlB;MAIA;IACD,CAXD;EAYA;AACD;;AAEDb,QAAQ,CAACiB,gBAAT,CAA0B,kBAA1B,EAA+CC,KAAD,IAAW;EACxDf,iBAAiB;EACjBJ,mBAAmB;AACnB,CAHD,E","sources":["webpack://tzm-section-block/./node_modules/jarallax/dist/jarallax.esm.js","webpack://tzm-section-block/webpack/bootstrap","webpack://tzm-section-block/webpack/runtime/define property getters","webpack://tzm-section-block/webpack/runtime/global","webpack://tzm-section-block/webpack/runtime/hasOwnProperty shorthand","webpack://tzm-section-block/webpack/runtime/make namespace object","webpack://tzm-section-block/./src/tzm-section-frontend.js"],"sourcesContent":["/*!\n * Jarallax v2.0.3 (https://github.com/nk-o/jarallax)\n * Copyright 2022 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\nfunction ready(callback) {\n  if ('complete' === document.readyState || 'interactive' === document.readyState) {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true\n    });\n  }\n}\n\n/* eslint-disable import/no-mutable-exports */\n\n/* eslint-disable no-restricted-globals */\nlet win$1;\n\nif ('undefined' !== typeof window) {\n  win$1 = window;\n} else if ('undefined' !== typeof global) {\n  win$1 = global;\n} else if ('undefined' !== typeof self) {\n  win$1 = self;\n} else {\n  win$1 = {};\n}\n\nvar global$2 = win$1;\n\nconst {\n  navigator\n} = global$2;\nconst isMobile = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\nlet $deviceHelper;\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\n\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n\n  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;\n} // Window height data\n\n\nlet wndH;\n\nfunction updateWndVars() {\n  if (isMobile) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global$2.innerHeight || document.documentElement.clientHeight;\n  }\n}\n\nupdateWndVars();\nglobal$2.addEventListener('resize', updateWndVars);\nglobal$2.addEventListener('orientationchange', updateWndVars);\nglobal$2.addEventListener('load', updateWndVars);\nready(() => {\n  updateWndVars();\n}); // list with all jarallax instances\n// need to render all in one scroll/resize event\n\nconst jarallaxList = []; // get all parents of the element.\n\nfunction getParents(elem) {\n  const parents = [];\n\n  while (null !== elem.parentElement) {\n    elem = elem.parentElement;\n\n    if (1 === elem.nodeType) {\n      parents.push(elem);\n    }\n  }\n\n  return parents;\n}\n\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n\n  jarallaxList.forEach((data, k) => {\n    const {\n      instance,\n      oldData\n    } = data;\n    const clientRect = instance.$item.getBoundingClientRect();\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW: global$2.innerWidth,\n      wndH\n    };\n    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n    jarallaxList[k].oldData = newData;\n\n    if (isResized) {\n      instance.onResize();\n    }\n\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n  global$2.requestAnimationFrame(updateParallax);\n}\n\nlet instanceID = 0; // Jarallax class\n\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n    self.instanceID = instanceID;\n    instanceID += 1;\n    self.$item = item;\n    self.defaults = {\n      type: 'scroll',\n      // type of parallax: scroll, scale, opacity, scale-opacity, scroll-opacity\n      speed: 0.5,\n      // supported value from -1 to 2\n      imgSrc: null,\n      imgElement: '.jarallax-img',\n      imgSize: 'cover',\n      imgPosition: '50% 50%',\n      imgRepeat: 'no-repeat',\n      // supported only for background, not for <img> tag\n      keepImg: false,\n      // keep <img> tag in it's default place\n      elementInViewport: null,\n      zIndex: -100,\n      disableParallax: false,\n      disableVideo: false,\n      // video\n      videoSrc: null,\n      videoStartTime: 0,\n      videoEndTime: 0,\n      videoVolume: 0,\n      videoLoop: true,\n      videoPlayOnlyVisible: true,\n      videoLazyLoading: true,\n      // events\n      onScroll: null,\n      // function(calculations) {}\n      onInit: null,\n      // function() {}\n      onDestroy: null,\n      // function() {}\n      onCoverImage: null // function() {}\n\n    }; // prepare data-options\n\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach(key => {\n      const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n\n      if (loweCaseOption && 'undefined' !== typeof self.defaults[loweCaseOption]) {\n        pureDataOptions[loweCaseOption] = dataOptions[key];\n      }\n    });\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options); // prepare 'true' and 'false' strings to boolean\n\n    Object.keys(self.options).forEach(key => {\n      if ('true' === self.options[key]) {\n        self.options[key] = true;\n      } else if ('false' === self.options[key]) {\n        self.options[key] = false;\n      }\n    }); // fix speed option [-1.0, 2.0]\n\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed))); // prepare disableParallax callback\n\n    if ('string' === typeof self.options.disableParallax) {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n\n    if ('function' !== typeof self.options.disableParallax) {\n      self.options.disableParallax = () => false;\n    } // prepare disableVideo callback\n\n\n    if ('string' === typeof self.options.disableVideo) {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n\n    if ('function' !== typeof self.options.disableVideo) {\n      self.options.disableVideo = () => false;\n    } // custom element to check if parallax in viewport\n\n\n    let elementInVP = self.options.elementInViewport; // get first item from array\n\n    if (elementInVP && 'object' === typeof elementInVP && 'undefined' !== typeof elementInVP.length) {\n      [elementInVP] = elementInVP;\n    } // check if dom element\n\n\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n\n    self.options.elementInViewport = elementInVP;\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed'\n    };\n\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  } // add styles to element\n  // eslint-disable-next-line class-methods-use-this\n\n\n  css(el, styles) {\n    if ('string' === typeof styles) {\n      return global$2.getComputedStyle(el).getPropertyValue(styles);\n    }\n\n    Object.keys(styles).forEach(key => {\n      el.style[key] = styles[key];\n    });\n    return el;\n  } // Extend like jQuery.extend\n  // eslint-disable-next-line class-methods-use-this\n\n\n  extend(out, ...args) {\n    out = out || {};\n    Object.keys(args).forEach(i => {\n      if (!args[i]) {\n        return;\n      }\n\n      Object.keys(args[i]).forEach(key => {\n        out[key] = args[i][key];\n      });\n    });\n    return out;\n  } // get window size and scroll position. Useful for extensions\n  // eslint-disable-next-line class-methods-use-this\n\n\n  getWindowData() {\n    return {\n      width: global$2.innerWidth || document.documentElement.clientWidth,\n      height: wndH,\n      y: document.documentElement.scrollTop\n    };\n  } // Jarallax functions\n\n\n  initImg() {\n    const self = this; // find image element\n\n    let $imgElement = self.options.imgElement;\n\n    if ($imgElement && 'string' === typeof $imgElement) {\n      $imgElement = self.$item.querySelector($imgElement);\n    } // check if dom element\n\n\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n\n      self.image.useImgTag = true;\n    } // true if there is img tag\n\n\n    if (self.image.$item) {\n      return true;\n    } // get image src\n\n\n    if (null === self.image.src) {\n      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n\n    return !(!self.image.bgImage || 'none' === self.image.bgImage);\n  }\n\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden',\n      willChange: 'transform,opacity'\n    };\n\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    } // set relative position and z-index to the parent\n\n\n    if ('static' === self.css(self.$item, 'position')) {\n      self.css(self.$item, {\n        position: 'relative'\n      });\n    }\n\n    if ('auto' === self.css(self.$item, 'z-index')) {\n      self.css(self.$item, {\n        zIndex: 0\n      });\n    } // container for parallax image\n\n\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex\n    }); // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n\n    if ('fixed' === this.image.position) {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'\n      });\n    }\n\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n    self.$item.appendChild(self.image.$container); // use img tag\n\n    if (self.image.useImgTag) {\n      imageStyles = self.extend({\n        'object-fit': self.options.imgSize,\n        'object-position': self.options.imgPosition,\n        'max-width': 'none'\n      }, containerStyles, imageStyles); // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n\n      if (self.image.src) {\n        imageStyles = self.extend({\n          'background-position': self.options.imgPosition,\n          'background-size': self.options.imgSize,\n          'background-repeat': self.options.imgRepeat,\n          'background-image': self.image.bgImage || `url(\"${self.image.src}\")`\n        }, containerStyles, imageStyles);\n      }\n    }\n\n    if ('opacity' === self.options.type || 'scale' === self.options.type || 'scale-opacity' === self.options.type || 1 === self.options.speed) {\n      self.image.position = 'absolute';\n    } // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n\n\n    if ('fixed' === self.image.position) {\n      const $parents = getParents(self.$item).filter(el => {\n        const styles = global$2.getComputedStyle(el);\n        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n        return parentTransform && 'none' !== parentTransform || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);\n      });\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    } // add position to parallax block\n\n\n    imageStyles.position = self.image.position; // insert parallax image\n\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item); // set initial position and size\n\n    self.onResize();\n    self.onScroll(true); // call onInit event\n\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    } // remove default user background\n\n\n    if ('none' !== self.css(self.$item, 'background-image')) {\n      self.css(self.$item, {\n        'background-image': 'none'\n      });\n    }\n\n    self.addToParallaxList();\n  } // add to parallax instances list\n\n\n  addToParallaxList() {\n    jarallaxList.push({\n      instance: this\n    });\n\n    if (1 === jarallaxList.length) {\n      global$2.requestAnimationFrame(updateParallax);\n    }\n  } // remove from parallax instances list\n\n\n  removeFromParallaxList() {\n    const self = this;\n    jarallaxList.forEach((data, key) => {\n      if (data.instance.instanceID === self.instanceID) {\n        jarallaxList.splice(key, 1);\n      }\n    });\n  }\n\n  destroy() {\n    const self = this;\n    self.removeFromParallaxList(); // return styles on container as before jarallax init\n\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles'); // null occurs if there is no style tag before jarallax init\n\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles'); // null occurs if there is no style tag before jarallax init\n\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      } // move img tag to its default position\n\n\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    } // remove additional dom elements\n\n\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    } // call onDestroy event\n\n\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    } // delete jarallax from item\n\n\n    delete self.$item.jarallax;\n  } // Fallback for removed function.\n  // Does nothing now.\n  // eslint-disable-next-line class-methods-use-this\n\n\n  clipContainer() {}\n\n  coverImage() {\n    const self = this;\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const {\n      speed\n    } = self.options;\n    const isScroll = 'scroll' === self.options.type || 'scroll-opacity' === self.options.type;\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0; // scroll parallax\n\n    if (isScroll) {\n      // scroll distance and height for image\n      if (0 > speed) {\n        scrollDist = speed * Math.max(contH, wndH);\n\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      } // size for scroll parallax\n\n\n      if (1 < speed) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (0 > speed) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n\n      scrollDist /= 2;\n    } // store scroll distance\n\n\n    self.parallaxScrollDistance = scrollDist; // vertical center\n\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    } // apply result to item\n\n\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: 'fixed' === self.image.position ? `${rect.left}px` : '0',\n      width: `${rect.width}px`\n    }); // call onCoverImage event\n\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    } // return some useful data. Used in the video cover function\n\n\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT\n      },\n      container: rect\n    };\n  }\n\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n\n  onScroll(force) {\n    const self = this;\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {}; // check if in viewport\n\n    let viewportRect = rect;\n\n    if (self.options.elementInViewport) {\n      viewportRect = self.options.elementInViewport.getBoundingClientRect();\n    }\n\n    self.isElementInViewport = 0 <= viewportRect.bottom && 0 <= viewportRect.right && viewportRect.top <= wndH && viewportRect.left <= global$2.innerWidth; // stop calculations if item is not in viewport\n\n    if (force ? false : !self.isElementInViewport) {\n      return;\n    } // calculate parallax helping variables\n\n\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH)); // calculate on how percent of section is visible\n\n    let visiblePercent = 1;\n\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    } // opacity\n\n\n    if ('opacity' === self.options.type || 'scale-opacity' === self.options.type || 'scroll-opacity' === self.options.type) {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    } // scale\n\n\n    if ('scale' === self.options.type || 'scale-opacity' === self.options.type) {\n      let scale = 1;\n\n      if (0 > self.options.speed) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    } // scroll\n\n\n    if ('scroll' === self.options.type || 'scroll-opacity' === self.options.type) {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter; // fix if parallax block in absolute position\n\n      if ('absolute' === self.image.position) {\n        positionY -= contT;\n      }\n\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n\n    self.css(self.image.$item, styles); // call onScroll event\n\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n        visiblePercent,\n        fromViewportCenter\n      });\n    }\n  }\n\n  onResize() {\n    this.coverImage();\n  }\n\n} // global definition\n\n\nconst jarallax$1 = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if ('object' === typeof HTMLElement ? items instanceof HTMLElement : items && 'object' === typeof items && null !== items && 1 === items.nodeType && 'string' === typeof items.nodeName) {\n    items = [items];\n  }\n\n  const len = items.length;\n  let k = 0;\n  let ret;\n\n  for (k; k < len; k += 1) {\n    if ('object' === typeof options || 'undefined' === typeof options) {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n\n    if ('undefined' !== typeof ret) {\n      return ret;\n    }\n  }\n\n  return items;\n};\n\njarallax$1.constructor = Jarallax;\n\n/*!\n * Name    : Video Worker\n * Version : 2.0.0\n * Author  : nK <https://nkdev.info>\n * GitHub  : https://github.com/nk-o/video-worker\n */\n\n/* eslint-disable import/no-mutable-exports */\n\n/* eslint-disable no-restricted-globals */\nlet win;\n\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\n\nvar global$1 = win; // Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\n\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\n\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length; // eslint-disable-next-line no-param-reassign\n\n    args = Array.prototype.slice.call(args);\n\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n\n};\nlet ID = 0;\nlet YoutubeAPIadded = 0;\nlet VimeoAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\n\nclass VideoWorker {\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      autoplay: false,\n      loop: false,\n      mute: false,\n      volume: 100,\n      showControls: true,\n      accessibilityHidden: false,\n      // start / end video time in seconds\n      startTime: 0,\n      endTime: 0\n    };\n    self.options = self.extend({}, self.options_default, options); // Fix wrong option name.\n    // Thanks to https://github.com/nk-o/video-worker/issues/13.\n\n    if (typeof self.options.showContols !== 'undefined') {\n      self.options.showControls = self.options.showContols;\n      delete self.options.showContols;\n    } // check URL\n\n\n    self.videoID = self.parseURL(url); // init\n\n    if (self.videoID) {\n      self.ID = ID;\n      ID += 1;\n      self.loadAPI();\n      self.init();\n    }\n  } // Extend like jQuery.extend\n  // eslint-disable-next-line class-methods-use-this\n\n\n  extend(...args) {\n    const out = args[0] || {};\n    Object.keys(args).forEach(i => {\n      if (!args[i]) {\n        return;\n      }\n\n      Object.keys(args[i]).forEach(key => {\n        out[key] = args[i][key];\n      });\n    });\n    return out;\n  }\n\n  parseURL(url) {\n    // parse youtube ID\n    function getYoutubeID(ytUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=)([^#\\&\\?]*).*/;\n      const match = ytUrl.match(regExp);\n      return match && match[1].length === 11 ? match[1] : false;\n    } // parse vimeo ID\n\n\n    function getVimeoID(vmUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n      const match = vmUrl.match(regExp);\n      return match && match[3] ? match[3] : false;\n    } // parse local string\n\n\n    function getLocalVideos(locUrl) {\n      // eslint-disable-next-line no-useless-escape\n      const videoFormats = locUrl.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n      const result = {};\n      let ready = 0;\n      videoFormats.forEach(val => {\n        // eslint-disable-next-line no-useless-escape\n        const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n\n        if (match && match[1] && match[2]) {\n          // eslint-disable-next-line prefer-destructuring\n          result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n          ready = 1;\n        }\n      });\n      return ready ? result : false;\n    }\n\n    const Youtube = getYoutubeID(url);\n    const Vimeo = getVimeoID(url);\n    const Local = getLocalVideos(url);\n\n    if (Youtube) {\n      this.type = 'youtube';\n      return Youtube;\n    }\n\n    if (Vimeo) {\n      this.type = 'vimeo';\n      return Vimeo;\n    }\n\n    if (Local) {\n      this.type = 'local';\n      return Local;\n    }\n\n    return false;\n  }\n\n  isValid() {\n    return !!this.videoID;\n  } // events\n\n\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || []; // add new callback in events list\n\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n\n  play(start) {\n    const self = this;\n\n    if (!self.player) {\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.playVideo) {\n      if (typeof start !== 'undefined') {\n        self.player.seekTo(start || 0);\n      }\n\n      if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n        self.player.playVideo();\n      }\n    }\n\n    if (self.type === 'vimeo') {\n      if (typeof start !== 'undefined') {\n        self.player.setCurrentTime(start);\n      }\n\n      self.player.getPaused().then(paused => {\n        if (paused) {\n          self.player.play();\n        }\n      });\n    }\n\n    if (self.type === 'local') {\n      if (typeof start !== 'undefined') {\n        self.player.currentTime = start;\n      }\n\n      if (self.player.paused) {\n        self.player.play();\n      }\n    }\n  }\n\n  pause() {\n    const self = this;\n\n    if (!self.player) {\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.pauseVideo) {\n      if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n        self.player.pauseVideo();\n      }\n    }\n\n    if (self.type === 'vimeo') {\n      self.player.getPaused().then(paused => {\n        if (!paused) {\n          self.player.pause();\n        }\n      });\n    }\n\n    if (self.type === 'local') {\n      if (!self.player.paused) {\n        self.player.pause();\n      }\n    }\n  }\n\n  mute() {\n    const self = this;\n\n    if (!self.player) {\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.mute();\n    }\n\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(0);\n    }\n\n    if (self.type === 'local') {\n      self.$video.muted = true;\n    }\n  }\n\n  unmute() {\n    const self = this;\n\n    if (!self.player) {\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.mute) {\n      self.player.unMute();\n    }\n\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(self.options.volume);\n    }\n\n    if (self.type === 'local') {\n      self.$video.muted = false;\n    }\n  }\n\n  setVolume(volume = false) {\n    const self = this;\n\n    if (!self.player || !volume) {\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.setVolume) {\n      self.player.setVolume(volume);\n    }\n\n    if (self.type === 'vimeo' && self.player.setVolume) {\n      self.player.setVolume(volume);\n    }\n\n    if (self.type === 'local') {\n      self.$video.volume = volume / 100;\n    }\n  }\n\n  getVolume(callback) {\n    const self = this;\n\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume);\n      });\n    }\n\n    if (self.type === 'local') {\n      callback(self.$video.volume * 100);\n    }\n  }\n\n  getMuted(callback) {\n    const self = this;\n\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n\n    if (self.type === 'youtube' && self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n\n    if (self.type === 'vimeo' && self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n\n    if (self.type === 'local') {\n      callback(self.$video.muted);\n    }\n  }\n\n  getImageURL(callback) {\n    const self = this;\n\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n\n    if (self.type === 'youtube') {\n      const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n      let step = 0;\n      const tempImg = new Image();\n\n      tempImg.onload = function () {\n        // if no thumbnail, youtube add their own image with width = 120px\n        if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n          // ok\n          self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n          callback(self.videoImage);\n        } else {\n          // try another size\n          step += 1;\n          this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        }\n      };\n\n      tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n    }\n\n    if (self.type === 'vimeo') {\n      let request = new XMLHttpRequest(); // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n\n      request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}`, true);\n\n      request.onreadystatechange = function () {\n        if (this.readyState === 4) {\n          if (this.status >= 200 && this.status < 400) {\n            // Success!\n            const response = JSON.parse(this.responseText);\n\n            if (response.thumbnail_url) {\n              self.videoImage = response.thumbnail_url;\n              callback(self.videoImage);\n            }\n          }\n        }\n      };\n\n      request.send();\n      request = null;\n    }\n  } // fallback to the old version.\n\n\n  getIframe(callback) {\n    this.getVideo(callback);\n  }\n\n  getVideo(callback) {\n    const self = this; // return generated video block\n\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    } // generate new video block\n\n\n    self.onAPIready(() => {\n      let hiddenDiv;\n\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      } // Youtube\n\n\n      if (self.type === 'youtube') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          host: 'https://www.youtube-nocookie.com',\n          videoId: self.videoID,\n          playerVars: {\n            autohide: 1,\n            rel: 0,\n            autoplay: 0,\n            // autoplay enable on mobile devices\n            playsinline: 1\n          }\n        }; // hide controls\n\n        if (!self.options.showControls) {\n          self.playerOptions.playerVars.iv_load_policy = 3;\n          self.playerOptions.playerVars.modestbranding = 1;\n          self.playerOptions.playerVars.controls = 0;\n          self.playerOptions.playerVars.showinfo = 0;\n          self.playerOptions.playerVars.disablekb = 1;\n        } // events\n\n\n        let ytStarted;\n        let ytProgressInterval;\n        self.playerOptions.events = {\n          onReady(e) {\n            // mute\n            if (self.options.mute) {\n              e.target.mute();\n            } else if (self.options.volume) {\n              e.target.setVolume(self.options.volume);\n            } // autoplay\n\n\n            if (self.options.autoplay) {\n              self.play(self.options.startTime);\n            }\n\n            self.fire('ready', e); // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n            // https://github.com/nk-o/video-worker/issues/2\n\n            if (self.options.loop && !self.options.endTime) {\n              const secondsOffset = 0.1;\n              self.options.endTime = self.player.getDuration() - secondsOffset;\n            } // volumechange\n\n\n            setInterval(() => {\n              self.getVolume(volume => {\n                if (self.options.volume !== volume) {\n                  self.options.volume = volume;\n                  self.fire('volumechange', e);\n                }\n              });\n            }, 150);\n          },\n\n          onStateChange(e) {\n            // loop\n            if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n              self.play(self.options.startTime);\n            }\n\n            if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n              ytStarted = 1;\n              self.fire('started', e);\n            }\n\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              self.fire('play', e);\n            }\n\n            if (e.data === global$1.YT.PlayerState.PAUSED) {\n              self.fire('pause', e);\n            }\n\n            if (e.data === global$1.YT.PlayerState.ENDED) {\n              self.fire('ended', e);\n            } // progress check\n\n\n            if (e.data === global$1.YT.PlayerState.PLAYING) {\n              ytProgressInterval = setInterval(() => {\n                self.fire('timeupdate', e); // check for end of video and play again or stop\n\n                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                  if (self.options.loop) {\n                    self.play(self.options.startTime);\n                  } else {\n                    self.pause();\n                  }\n                }\n              }, 150);\n            } else {\n              clearInterval(ytProgressInterval);\n            }\n          },\n\n          onError(e) {\n            self.fire('error', e);\n          }\n\n        };\n        const firstInit = !self.$video;\n\n        if (firstInit) {\n          const div = document.createElement('div');\n          div.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(div);\n          document.body.appendChild(hiddenDiv);\n        }\n\n        self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n\n        if (firstInit) {\n          self.$video = document.getElementById(self.playerID); // add accessibility attributes\n\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          } // get video width and height\n\n\n          self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n          self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n        }\n      } // Vimeo\n\n\n      if (self.type === 'vimeo') {\n        self.playerOptions = {\n          // GDPR Compliance.\n          dnt: 1,\n          id: self.videoID,\n          autopause: 0,\n          transparent: 0,\n          autoplay: self.options.autoplay ? 1 : 0,\n          loop: self.options.loop ? 1 : 0,\n          muted: self.options.mute ? 1 : 0\n        };\n\n        if (self.options.volume) {\n          self.playerOptions.volume = self.options.volume;\n        } // hide controls\n\n\n        if (!self.options.showControls) {\n          self.playerOptions.badge = 0;\n          self.playerOptions.byline = 0;\n          self.playerOptions.portrait = 0;\n          self.playerOptions.title = 0;\n          self.playerOptions.background = 1;\n        }\n\n        if (!self.$video) {\n          let playerOptionsString = '';\n          Object.keys(self.playerOptions).forEach(key => {\n            if (playerOptionsString !== '') {\n              playerOptionsString += '&';\n            }\n\n            playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n          }); // we need to create iframe manually because when we create it using API\n          // js events won't triggers after iframe moved to another place\n\n          self.$video = document.createElement('iframe');\n          self.$video.setAttribute('id', self.playerID);\n          self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n          self.$video.setAttribute('frameborder', '0');\n          self.$video.setAttribute('mozallowfullscreen', '');\n          self.$video.setAttribute('allowfullscreen', '');\n          self.$video.setAttribute('title', 'Vimeo video player'); // add accessibility attributes\n\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n        }\n\n        self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions); // set current time for autoplay\n\n        if (self.options.startTime && self.options.autoplay) {\n          self.player.setCurrentTime(self.options.startTime);\n        } // get video width and height\n\n\n        self.player.getVideoWidth().then(width => {\n          self.videoWidth = width || 1280;\n        });\n        self.player.getVideoHeight().then(height => {\n          self.videoHeight = height || 720;\n        }); // events\n\n        let vmStarted;\n        self.player.on('timeupdate', e => {\n          if (!vmStarted) {\n            self.fire('started', e);\n            vmStarted = 1;\n          }\n\n          self.fire('timeupdate', e); // check for end of video and play again or stop\n\n          if (self.options.endTime) {\n            if (self.options.endTime && e.seconds >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.on('play', e => {\n          self.fire('play', e); // check for the start time and start with it\n\n          if (self.options.startTime && e.seconds === 0) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.on('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.on('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.on('loaded', e => {\n          self.fire('ready', e);\n        });\n        self.player.on('volumechange', e => {\n          self.fire('volumechange', e);\n        });\n        self.player.on('error', e => {\n          self.fire('error', e);\n        });\n      } // Local\n\n\n      function addSourceToLocal(element, src, type) {\n        const source = document.createElement('source');\n        source.src = src;\n        source.type = type;\n        element.appendChild(source);\n      }\n\n      if (self.type === 'local') {\n        if (!self.$video) {\n          self.$video = document.createElement('video'); // show controls\n\n          if (self.options.showControls) {\n            self.$video.controls = true;\n          } // mute\n\n\n          if (self.options.mute) {\n            self.$video.muted = true;\n          } else if (self.$video.volume) {\n            self.$video.volume = self.options.volume / 100;\n          } // loop\n\n\n          if (self.options.loop) {\n            self.$video.loop = true;\n          } // autoplay enable on mobile devices\n\n\n          self.$video.setAttribute('playsinline', '');\n          self.$video.setAttribute('webkit-playsinline', ''); // add accessibility attributes\n\n          if (self.options.accessibilityHidden) {\n            self.$video.setAttribute('tabindex', '-1');\n            self.$video.setAttribute('aria-hidden', 'true');\n          }\n\n          self.$video.setAttribute('id', self.playerID);\n          hiddenDiv.appendChild(self.$video);\n          document.body.appendChild(hiddenDiv);\n          Object.keys(self.videoID).forEach(key => {\n            addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);\n          });\n        }\n\n        self.player = self.player || self.$video;\n        let locStarted;\n        self.player.addEventListener('playing', e => {\n          if (!locStarted) {\n            self.fire('started', e);\n          }\n\n          locStarted = 1;\n        });\n        self.player.addEventListener('timeupdate', function (e) {\n          self.fire('timeupdate', e); // check for end of video and play again or stop\n\n          if (self.options.endTime) {\n            if (self.options.endTime && this.currentTime >= self.options.endTime) {\n              if (self.options.loop) {\n                self.play(self.options.startTime);\n              } else {\n                self.pause();\n              }\n            }\n          }\n        });\n        self.player.addEventListener('play', e => {\n          self.fire('play', e);\n        });\n        self.player.addEventListener('pause', e => {\n          self.fire('pause', e);\n        });\n        self.player.addEventListener('ended', e => {\n          self.fire('ended', e);\n        });\n        self.player.addEventListener('loadedmetadata', function () {\n          // get video width and height\n          self.videoWidth = this.videoWidth || 1280;\n          self.videoHeight = this.videoHeight || 720;\n          self.fire('ready'); // autoplay\n\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n        });\n        self.player.addEventListener('volumechange', e => {\n          self.getVolume(volume => {\n            self.options.volume = volume;\n          });\n          self.fire('volumechange', e);\n        });\n        self.player.addEventListener('error', e => {\n          self.fire('error', e);\n        });\n      }\n\n      callback(self.$video);\n    });\n  }\n\n  init() {\n    const self = this;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n\n  loadAPI() {\n    const self = this;\n\n    if (YoutubeAPIadded && VimeoAPIadded) {\n      return;\n    }\n\n    let src = ''; // load Youtube API\n\n    if (self.type === 'youtube' && !YoutubeAPIadded) {\n      YoutubeAPIadded = 1;\n      src = 'https://www.youtube.com/iframe_api';\n    } // load Vimeo API\n\n\n    if (self.type === 'vimeo' && !VimeoAPIadded) {\n      VimeoAPIadded = 1; // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n\n      if (typeof global$1.Vimeo !== 'undefined') {\n        return;\n      }\n\n      src = 'https://player.vimeo.com/api/player.js';\n    }\n\n    if (!src) {\n      return;\n    } // add script in head section\n\n\n    let tag = document.createElement('script');\n    let head = document.getElementsByTagName('head')[0];\n    tag.src = src;\n    head.appendChild(tag);\n    head = null;\n    tag = null;\n  }\n\n  onAPIready(callback) {\n    const self = this; // Youtube\n\n    if (self.type === 'youtube') {\n      // Listen for global YT player callback\n      if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n        // Prevents Ready event from being called twice\n        loadingYoutubePlayer = 1; // Creates deferred so, other players know when to wait.\n\n        global$1.onYouTubeIframeAPIReady = function () {\n          global$1.onYouTubeIframeAPIReady = null;\n          loadingYoutubeDefer.resolve('done');\n          callback();\n        };\n      } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n        callback();\n      } else {\n        loadingYoutubeDefer.done(() => {\n          callback();\n        });\n      }\n    } // Vimeo\n\n\n    if (self.type === 'vimeo') {\n      if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n        loadingVimeoPlayer = 1;\n        const vimeoInterval = setInterval(() => {\n          if (typeof global$1.Vimeo !== 'undefined') {\n            clearInterval(vimeoInterval);\n            loadingVimeoDefer.resolve('done');\n            callback();\n          }\n        }, 20);\n      } else if (typeof global$1.Vimeo !== 'undefined') {\n        callback();\n      } else {\n        loadingVimeoDefer.done(() => {\n          callback();\n        });\n      }\n    } // Local\n\n\n    if (self.type === 'local') {\n      callback();\n    }\n  }\n\n}\n\nfunction jarallaxVideo$1(jarallax = global$2.jarallax) {\n  if ('undefined' === typeof jarallax) {\n    return;\n  }\n\n  const Jarallax = jarallax.constructor; // append video after when block will be visible.\n\n  const defOnScroll = Jarallax.prototype.onScroll;\n\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n    defOnScroll.apply(self);\n    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();\n\n    if (isReady) {\n      self.isVideoInserted = true;\n      self.video.getVideo(video => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          willChange: 'transform,opacity',\n          margin: 0,\n          zIndex: -1\n        });\n        self.$video = video; // add Poster attribute to self-hosted video\n\n        if ('local' === self.video.type) {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (self.image.$item && 'IMG' === self.image.$item.tagName && self.image.$item.src) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        } // insert video tag\n\n\n        self.image.$container.appendChild(video); // remove parent video element (created by VideoWorker)\n\n        $parent.parentNode.removeChild($parent); // call onVideoInsert event\n\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  }; // cover video\n\n\n  const defCoverImage = Jarallax.prototype.coverImage;\n\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n\n    if (imageData && self.video && node && ('IFRAME' === node || 'VIDEO' === node)) {\n      let h = imageData.image.height;\n      let w = h * self.image.width / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = w * self.image.height / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      } // add video height over than need to hide controls\n\n\n      if ('IFRAME' === node) {\n        h += 400;\n        mt -= 200;\n      }\n\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`\n      });\n    }\n\n    return imageData;\n  }; // init video\n\n\n  const defInitImg = Jarallax.prototype.initImg;\n\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n\n    return defaultResult;\n  };\n\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    } // Init video api\n\n\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: self.options.videoVolume ? 0 : 1,\n      volume: self.options.videoVolume || 0\n    }); // call onVideoWorkerInit event\n\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block'; // set image width and height\n\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      } // if parallax will not be inited, we can add thumbnail on background.\n\n\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL(url => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            } // set new background\n\n\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover'\n            });\n          });\n        } // init video\n\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n\n              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video; // set video width and height\n\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll(); // hide image\n\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n        video.on('ended', () => {\n          self.videoEnded = true;\n\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true; // show default image if video loading error.\n\n          resetDefaultImage();\n        });\n        self.video = video; // set image if not exists\n\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\n          if ('local' !== video.type) {\n            video.getImageURL(url => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n            return false;\n          }\n        }\n      }\n    }\n\n    return defaultResult;\n  }; // Destroy video parallax\n\n\n  const defDestroy = Jarallax.prototype.destroy;\n\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n\n    defDestroy.apply(self);\n  };\n}\n\nfunction jarallaxElement$1(jarallax = global$2.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n\n  if ('undefined' === typeof jarallax) {\n    return;\n  }\n\n  const Jarallax = jarallax.constructor; // redefine default methods\n\n  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {\n    const def = Jarallax.prototype[key];\n\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n\n      if ('initImg' === key && null !== self.$item.getAttribute('data-jarallax-element')) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n\n      if ('element' !== self.options.type) {\n        return def.apply(self, args);\n      }\n\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n\n      switch (key) {\n        case 'init':\n          {\n            const speedArr = `${self.pureOptions.speed}`.split(' ');\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(' ');\n            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n            def.apply(self, args); // restore background image if available.\n\n            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n\n            if (originalStylesTag) {\n              self.$item.setAttribute('style', originalStylesTag);\n            }\n\n            return true;\n          }\n\n        case 'onResize':\n          {\n            const defTransform = self.css(self.$item, 'transform');\n            self.css(self.$item, {\n              transform: ''\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left\n            };\n            self.css(self.$item, {\n              transform: defTransform\n            });\n            break;\n          }\n\n        case 'onScroll':\n          {\n            const wnd = self.getWindowData();\n            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (null !== self.options.thresholdY && moveY > self.options.thresholdY) my = 0;\n            if (null !== self.options.thresholdX && moveX > self.options.thresholdX) mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`\n            });\n            break;\n          }\n\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n\n      return def.apply(self, args);\n    };\n  });\n}\n\nconst jarallax = jarallax$1;\nconst jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideo$1(jarallax);\n};\nconst jarallaxElement = function jarallaxElement() {\n  return jarallaxElement$1(jarallax);\n};\n\nexport { jarallax, jarallaxElement, jarallaxVideo };\n//# sourceMappingURL=jarallax.esm.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\n\nimport { jarallax, jarallaxVideo } from 'jarallax';\njarallaxVideo(); // Optional video extension\n\nfunction initSectionParallax() {\n\tjarallax(document.querySelectorAll('.has-parallax-fixed'), {\n\t\tspeed: 0,\n\t});\n\tjarallax(document.querySelectorAll('.has-parallax-slow'), {\n\t\tspeed: 0.15,\n\t});\n\tjarallax(document.querySelectorAll('.has-parallax-medium'), {\n\t\tspeed: 0.4,\n\t});\n\tjarallax(document.querySelectorAll('.has-parallax-fast'), {\n\t\tspeed: 1.2,\n\t});\n}\n\nfunction initSectionHeight() {\n\tvar sections = document.querySelectorAll('[data-height-selector]');\n\n\tif (sections && sections.length > 0) {\n\t\tsections.forEach((section) => {\n\t\t\tvar selector = section.dataset.heightSelector;\n\t\t\tvar selectorEl = document.querySelector(selector);\n\n\t\t\tif (selectorEl) {\n\t\t\t\tvar selectorHeight = selectorEl.offsetHeight;\n\t\t\t\tsection.style.setProperty(\n\t\t\t\t\t'--subtract-height',\n\t\t\t\t\tselectorHeight + 'px'\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n}\n\ndocument.addEventListener('DOMContentLoaded', (event) => {\n\tinitSectionHeight();\n\tinitSectionParallax();\n});\n"],"names":["jarallax","jarallaxVideo","initSectionParallax","document","querySelectorAll","speed","initSectionHeight","sections","length","forEach","section","selector","dataset","heightSelector","selectorEl","querySelector","selectorHeight","offsetHeight","style","setProperty","addEventListener","event"],"sourceRoot":""}